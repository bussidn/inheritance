package exercice;

import list.exercice.hierarchy.vivant.domaine.regne.Animal;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.Vertebrate;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.Mammal;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.Felidae;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.espece.Cat;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.espece.Horse;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class PreservingLiskov {

    private static final List<Cat> cats = new ArrayList<>(someList());
    private static final List<Felidae> felidaes = new ArrayList<>(someList());
    private static final List<Mammal> mammals = new ArrayList<>(someList());
    private static final List<Vertebrate> vertebrates = new ArrayList<>(someList());
    private static final List<Animal> animals = new ArrayList<>(someList());

    //
//    You decided that :
//
//          "if S is a subtype of T, List<S> is a subtype of List<T>
//
//    It follows the intuition that a List<Cat> is a List<Animal>
//    It means that the generic container List<> preserves the original inheritance order.
//
//    Until further notice, we will consider that this hypothesis is true.
//    Let's call it : ListPreservingInheritance.
//
//    For our hierarchy of the living, it means that the hierarchy tree generated by List<>
//    preserves the original order and therefore looks like :
//
//                             Animal                 List<Animal>
//                                ↑                        ↑
//                            Vertebrate            List<Vertebrate>
//                                ↑                        ↑
//    List<> applied to         Mammal        =       List<Mammal>
//                                ↑                        ↑
//                             Felidae                List<Felidae>
//                                ↑                        ↑
//                               Cat                    List<Cat>
//
//    For example, considering that List<Cat> s a subtype of List<Mammal>,
//    liskov principle is saying that :
//
//    - any method that accept a List<Mammal> should also accept and work flawlessly with a List<Cat> without
//    knowing it is manipulating a List<Cat>
//
//    - any property true for type List<Mammal> should also be true for List<Cat>
//
//    It is important to understand that we are dealing with a type system. All names referring to a part of
//    the living hierarchy are type.
//
//          "Cat, Mammal, Animal, List<Mammal>, List<Vertebrate>, List<Cat> are all different types"
//
//    Now let's explore the consequences of stating the ListPreservingLiskov hypothesis.
//
//    Exercise:
//
//    I. Following the rules of Liskov Principle
//
//          We will start the exercise by considering List<Mammal> because it is the central type of our hierarchy.
//          It will allow us to reason with the upper part of the tree or the lower part of the tree.
//
//          So if you think that the answer to some question is : List<Mammal> & List<Vertebrate> & List<Animal>
//          then you are referring to the upper part of the List<> Tree.
//          You can instead say that the answer is : all classes that are super(type) of Mammal.
//
//          And if you think that the answer to some question is : List<Mammal> & List<Felidae> & List<Cat>
//          then you are referring to the lower part of the List<> Tree.
//          You can instead say that the answer is : all classes that extend Mammal.
//
//      1. -> Can you list all subtypes of List<Mammal> ?
//
//      2. -> remember that Liskov principle can be seen as
//              - any property true for a type T should also be true for all subtypes S of T
//
//          Considering this, if a property is true for List<Mammal>, which other types should have that property ?
//
//      3.  Consider the following property p :
//          p(Type) = "I can add any Mammal instance to an instance of {Type}"
//
//          -> is property p true for Type = List<Mammal> ?
//          -> according to Liskov principle, which other types that property should also be true for ?
//
//      4.  "addBonusMammal" is a function that adds a Mammal instance to a list.
//          It is the embodiment of the property p(T).
//
//          The following method tries to call "addBonusMammal" for different types.
//          -> uncomment the lines corresponding to the types we determined it should work for.
//
//          It should not compile yet. It is perfectly normal, let it be.
//
    public static void followingLiskov() {

//        None of the calls below  compile at first except for Mammals.

//        addBonusMammal(animals);
//        addBonusMammal(vertebrates);
        addBonusMammal(mammals);
//        addBonusMammal(felidaes);
//        addBonusMammal(cats);
    }

    //
//      5.  The only types "addBonusMammal" should accept are the one for which the property p(T) is true.
//          And it should accept all of them.
//
//          For now, it only accepts List<Mammal>
//          But in order for our code to be as flexible as possible, we would like to be able to accept all types for
//          which p(T) is true.
//
//          Basically, we want the previously uncommented lines to compile now.
//
//          -> Change the erasue of the "addBonusMammal" method so the previously uncommented lines compile.
//          You will face issues with the body of the method. While it first compiles, the changes you have
//          to make to fulfill this exercise's requirements should make it not compile anymore.
//          Don't bother and comment the body of the method.
//
//          Hint : if you don't understand how to do this part, you should use a bounded wildcard
//
    private static void addBonusMammal(List<Mammal> mammals) {
        // comment below as soon as it does not compile anymore
        mammals.add(randomBonusMammal());
    }

    //
//      6.  -> uncomment the body of the "addBonusMammal" method above and try to make it compile.
//
//          Hint :  Any "solution" should be with weird (and unsafe) casts and/or very alarming warnings.
//                  That's why it is only asked to "try".
//
//      7.   At this point, we have followed Liskov + ListPreservingLiskov rules and we are left with a code that
//           have to choose between a coherent erasure and a working body. Basically, the code will have one of these
//           property :
//
//           - the method cannot accept all the types we would like it to accept
//           - the implementation of the method is unsafe when it compiles
//
//
//  II. Back to intuition
//
//    We will try to use intuition again. Forget Liskov for a short time. This time, instead of trying to
//    create a general rule like "list is preserving Liskov", we will look at each type individually and see
//    what the intuition has to say.
//
//    1. According to your own logic, which of these types should verify the property p.
//       p(Type) = "I can add any Mammal instance to an instance of {Type}"
//       Otherwise said, in which of these list would you try to add an instance of Mammal and expect the list to
//       accept it ?
//
//          List<Animal>
//          List<Vertebrate>
//          List<Felidae>
//          List<Cat>
//
//      Hint :  you should ask yourself "Can I add any Mammal instance, for example a Horse, to a list of cats ?"
//              Do the same for every proposed type.
//
//    2. In the following method, change the erasure so it accepts the types you chose on the previous question
//       and also reject all others.
//
    private static void alsoAddBonusMammal(List<Mammal> mammals) {
        mammals.add(randomBonusMammal());
    }

//
//    3. Check that it works by uncommenting tje proper lines on the following method
//
    public static void followingIntuition() {
//        alsoAddBonusMammal(animals);
//        alsoAddBonusMammal(vertebrates);
        alsoAddBonusMammal(mammals);
//        alsoAddBonusMammal(felidaes);
//        alsoAddBonusMammal(cats);
    }

//
//    We saw that the main hypothesis :
//
//          "If S is a subtype of T, List<S> is a subtype of List<T>"
//
//    lead to a contradictory situation.
//    Besides, we found a property that is a counter example of the liskov law.
//
//    The difficult part when intuiting that this hypothesis is false is the ability to differentiate those two
//    statements :
//
//          - each element of a List<Cat> is an instance of Cat and therefore, is also an instance of Animal,
//              which is a true statement.
//
//          is a different statement than
//
//          - a CatList (type-wise) is also an AnimalList (type-wise), which is false
//
//    The sentence "a list of cat is also a list of animals", while not appearing so, is ambiguous as it can be
//    interpreted as both meanings.
//    Unfortunately, the intuition is leading us towards the first which is not what Liskoc principle is about.
//    Liskov is about the whole type and its properties while our intuition think only in term of each element type.
//    In our example of List<>, the first is the whole List<T>, while the second is only T.
//    There's methods on the List<> container like "add" or "get" that you have to take into consideration when
//    looking at all that List<T> has to offer (all its properties), not only T.
//
//    In the second part of this exercise, we saw that the "add" method of a list induced a property that not only
//    was a counter example of the ListPreservingLiskov hypothesis but was a lot more.
//    It was an example o verifying the ListReversingLiskov hypothesis as all the list<Mammal> that verify the
//    property p were the list composed with the supertypes of Mammal !
//    While a single counter example is enough to disprove an hypothesis, finding an example working is not enough
//    to prove an hypothesis. We have to check if it's true all the time !
//
//    So was our intuition completely wrong ? Is a List<Animal> also a List<Mammal> ?
//
//    If you haven't completed the ReversingLiskov exercise, now is the time. We will explore that second hypothesis.
//    Else go to the general conclusion.
//

//
//    utility methods below
//

    private static Mammal randomBonusMammal() {
        return new Horse("Charles", Mammal.Fur.BLACK);
    }


    private static List<Cat> someList() {
        return Arrays.asList(
                new Cat("Felix", Mammal.Fur.BLACK_AND_WHITE),
                new Cat("Garfield", Mammal.Fur.ORANGE),
                new Cat("Madcat", Mammal.Fur.BLACK),
                new Cat("Grumpy Cat", Mammal.Fur.GREY)
        );
    }
}
