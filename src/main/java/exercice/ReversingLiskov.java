package exercice;

import list.exercice.hierarchy.vivant.domaine.regne.Animal;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.Vertebrate;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.Mammal;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.Felidae;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.espece.Cat;
import list.exercice.hierarchy.vivant.domaine.regne.embranchements.classe.ordre.espece.Horse;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ReversingLiskov {

    private static final List<Cat> cats = new ArrayList<>(someList());
    private static final List<Felidae> felidaes = new ArrayList<>(someList());
    private static final List<Mammal> mammals = new ArrayList<>(someList());
    private static final List<Vertebrate> vertebrates = new ArrayList<>(someList());
    private static final List<Animal> animals = new ArrayList<>(someList());

    //
//    You decided that :
//
//          "if S is a subtype of T, List<S> is a supertype of List<T>
//
//    It means that the generic container List<> reverses the original inheritance order.
//    It normally goes against intuition, but let's explore that statement anyway, because rumor says that sometimes
//    intuition is wrong.
//
//    Until further notice, we will consider that this hypothesis is true.
//    Let's call it : ListReversingInheritance.
//
//    For our hierarchy of the living, it means that the hierarchy tree generated by List<>
//    reverses the original order and therefore looks like :
//
//                             Animal                  List<Cat>
//                                ↑                        ↑
//                            Vertebrate              List<Felidae>
//                                ↑                        ↑
//    List<> applied to         Mammal        =       List<Mammal>
//                                ↑                        ↑
//                             Felidae              List<Vertebrate>
//                                ↑                        ↑
//                               Cat                  List<Animal>
//
//
//      ↑ is the inheritance arrow, it means that the type below is a subtype of the type above.
//
//    For example, considering that List<Animal> s a subtype of List<Mammal>,
//    liskov principle is saying that :
//
//    - any method that accept a List<Mammal> should also accept and work flawlessly with a List<Animal> without
//    knowing it is manipulating a List<Animal>
//
//    - any property true for type List<Mammal> should also be true for List<Animal>
//
//    It is important to understand that we are dealing with a type system. All names referring to a part of
//    the living hierarchy are type.
//
//          "Cat, Mammal, Animal, List<Mammal>, List<Vertebrate>, List<Cat> are all different types"
//
//    Now let's explore the consequences of stating the ListPreservingLiskov hypothesis.
//
//    Exercise:
//
//    I. Following the rules of Liskov Principle
//
//          We will start the exercise by considering List<Mammal> because it is the central type of our hierarchy.
//          It will allow us to reason with the upper part of the tree or the lower part of the tree.
//
//          So if you think that the answer to some question is : List<Mammal> & List<Vertebrate> & List<Animal>
//          then you are referring to the upper part of the List<> Tree.
//          You can instead say that the answer is : all classes that are super(type) of Mammal.
//
//          And if you think that the answer to some question is : List<Mammal> & List<Felidae> & List<Cat>
//          then you are referring to the lower part of the List<> Tree.
//          You can instead say that the answer is : all classes that extend Mammal.
//
//      1. -> Can you list all subtypes of List<Mammal> ?
//
//      2. -> remember that Liskov principle can be seen as
//              - any property true for a type T should also be true for all subtypes S of T
//
//          Considering this, if a property is true for List<Mammal>, which other types should have that property ?
//
//      3.  Consider the following property p :
//          p(Type) = "An instance of {Type} can display the fur color of all its elements"
//
//          -> is property p true for Type = List<Mammal> ?
//          -> according to Liskov principle, which other types that property should also be true for ?
//
//      4.  "displayFur" is a function that display the fur color of all elements of a provided list.
//          It is the embodiment of the property p(T).
//
//          The following method tries to call "displayFur" for different types.
//          -> uncomment the lines corresponding to the types we determined it should work for.
//
//          It should not compile yet. It is perfectly normal, let it be.
//
    public static void followingLiskov() {

//        None of the calls below  compile at first except for Mammals.

//        displayFur(animals);
//        displayFur(vertebrates);
        displayFur(mammals);
//        displayFur(felidaes);
//        displayFur(cats);
    }

    //
//      5.  The only types "displayFur" should accept are the one for which the property p(T) is true.
//          And it should accept all of them.
//
//          For now, it only accepts List<Mammal>
//          But in order for our code to be as flexible as possible, we would like to be able to accept all types for
//          which p(T) is true.
//
//          Basically, we want the previously uncommented lines to compile now.
//
//          -> Change the erasure of the "displayFur" method so the previously uncommented lines compile.
//          You will face issues with the body of the method. While it first compiles, the changes you have
//          to make to fulfill this exercise's requirements should make it not compile anymore.
//          Don't bother and comment the body of the method.
//
//          Hint : if you don't understand how to do this part, you should use a bounded wildcard
//
    @SuppressWarnings("Convert2MethodRef")
    private static void displayFur(List<Mammal> mammals) {
        // comment below as soon as it does not compile anymore
        mammals.forEach(element -> element.fur());
    }

    //
//      6.  -> uncomment the body of the "displayFur" method above and try to make it compile.
//
//          Hint :  Any "solution" should be with weird (and unsafe) casts and/or very alarming warnings.
//                  That's why it is only asked to "try".
//
//      7.   At this point, we have followed Liskov + ListReversingLiskov rules and we are left with a code that
//           have to choose between a coherent erasure and a working body. Basically, the code will have one of these
//           property :
//
//           - the method cannot accept all the types we would like it to accept
//           - the implementation of the method is unsafe when it compiles
//
//      In fact, the wanted erasure and implementation are incompatible at a very deep level.
//      When facing such an issue, we have to consider the validity of our starting hypotheses.
//      Either Liskov principle is wrong (it is not) or ListReversingLiskov is wrong. (it is)
//
//
//  II. Back to intuition
//
//    We will try to use intuition again. Forget Liskov for a short time. This time, instead of trying to
//    create a general rule like "list is reversing Liskov", we will look at each type individually and see
//    what the intuition has to say.
//
//    1. According to your own logic, which of these types should verify the property p.
//       p(Type) = "An instance of {Type} can display the fur color of all its elements"
//       Otherwise said, which of these list should be able to display fur colors ?
//
//          List<Animal>
//          List<Vertebrate>
//          List<Felidae>
//          List<Cat>
//
//      Hint :  you should ask yourself "Can I display the fur color of any element of that list ?"
//              Do the same for every proposed type.
//
//    2. In the following method, change the erasure so it accepts the types you chose on the previous question
//       and also reject all others.
//
    private static void alsoDisplayFur(List<Mammal> mammals) {
        mammals.forEach(Mammal::fur);
    }

    //
//    3. Check that it works by uncommenting the proper lines on the following method
//
    public static void followingIntuition() {
//        alsoDisplayFur(animals);
//        alsoDisplayFur(vertebrates);
        alsoDisplayFur(mammals);
//        alsoDisplayFur(felidaes);
//        alsoDisplayFur(cats);
    }

//
//    We saw that the main hypothesis :
//
//          "If S is a subtype of T, List<S> is a supertype of List<T>"
//
//    lead to a contradictory situation.
//    Besides, we found a property that is a counter example of the liskov law if we accept that hypothesis.
//
//    If you haven't completed the PreservingLiskov exercise, now is the time. We will explore that second hypothesis.
//    Else go to the general conclusion.
//

//
//    utility methods below
//

    private static List<Cat> someList() {
        return Arrays.asList(
                new Cat("Felix", Mammal.Fur.BLACK_AND_WHITE),
                new Cat("Garfield", Mammal.Fur.ORANGE),
                new Cat("Madcat", Mammal.Fur.BLACK),
                new Cat("Grumpy Cat", Mammal.Fur.GREY)
        );
    }
}
